Evaluate Performance Improvements

  Describe dynamic management views and functions
    SQL Server provides several hundred dynamic management objects. These objects contain system information that can be used to monitor the health of a server instance, diagnose problems, and tune performance. Dynamic management views and functions return internal data about the state of the database or the instance. Dynamic Management Objects can be either views (DMVs) or functions (DMFs), but most people use the acronym DMV to refer to both types of object. There are two levels of DMVs: server scoped and database scoped. Server scoped objects require VIEW SERVER STATE permission on the server, and database scoped objects require the VIEW DATABASE STATE permission within the database. The names of the DMVs are all prefixed with sys.dm_ followed by the functional area and then the specific function of the object. SQL Server supports three categories of DMVs:

      Database-related dynamic management objects
      Query execution related dynamic management objects
      Transaction related dynamic management objects

  Describe wait statistics
    Wait statistics are broken down into three types of waits: resource waits, queue waits, and external waits.

      Resource waits occur when a worker thread in SQL Server requests access to a resource that is currently being used by a thread. Examples of resources waits are locks, latches, and disk I/O waits.
      Queue waits occur when a worker thread is idle and waiting for work to be assigned. Example queue waits are deadlock monitoring and deleted record cleanup.
      External waits occur when SQL Server is waiting on an external process like a linked server query to complete. An example of an external wait is a network wait related to returning a large result set to a client application.

   This data is aggregated in the DMV sys.dm_os_wait_stats (and in sys.dm_db_wait_stats in Azure SQL Database) and is also tracked for active sessions in sys.dm_exec_session_wait_stats.

   There are many wait types that relate to specific and common SQL Server performance issues:

      RESOURCE_SEMAPHORE waits—this wait type is indicative of queries waiting on memory to become available, and may indicate excessive memory grants to some queries. This problem is typically observed by long query runtimes or even time outs. These wait types can be caused by out-of-date statistics, missing indexes, and excessive query concurrency.
      LCK_M_X waits—frequent occurrences of this wait type can indicate a blocking problem, that can be solved by either changing to the READ COMMITTED SNAPSHOT isolation level, or making changes in indexing to reduce transaction times, or possibly better transaction management within T-SQL code.
      PAGEIOLATCH_SH waits—this wait type can indicate a problem with indexes (or a lack of useful indexes), where SQL Server is scanning too much data. Alternatively, if the wait count is low, but the wait time is high, it can indicate storage performance problems. You can observe this behavior by analyzing the data in the waiting_tasks_count and the wait_time_ms in the sys.dm_os_wait_stats DMV, to calculate an average wait time for a given wait type.
      SOS_SCHEDULER_YIELD waits---this wait type can indicate high CPU utilization, which is correlated with either high number of large scans, or missing indexes, often in conjunction with high numbers of CXPACKET waits.
      CXPACKET waits—If this wait type is high it can indicate improper configuration. Prior to SQL Server 2019, the Max Degree of Parallelism (MaxDOP) default setting is to use all available CPUs for queries. Additionally, the cost threshold for parallelism (CTfP) setting defaults to 5, which can lead to small queries being executed in parallel, which can limit throughput. Lowering MaxDOP and increasing CTfP can reduce this wait type, but the CXPACKET wait type can also indicate high CPU utilization, which is typically resolved through index tuning.
      PAGEIOLATCH_UP—This wait type on data pages 2:1:1 can indicate TempDB contention on Page Free Space (PFS) data pages. Each data file has one PFS page per approximately 64MB of data. This wait is typically caused by only having one TempDB file, as prior to SQL Server 2016 the default behavior was to use one data file for TempDB. The best practice is to use one file per CPU core up to eight files. It is also important to ensure your TempDB data files are the same size and have the same autogrowth settings to ensure they are used evenly. SQL Server 2016 and higher control the growth of TempDB data files to ensure they grow in a consistent, simultaneous fashion.

  Tune Indexes
    The most common (and most effective) method for tuning T-SQL queries is to evaluate and adjust your indexing strategy. Your goal should always be to get the most benefit out of the smallest number of indexes on your tables.

    A common performance tuning approach is as follows:

      Evaluate existing index usage using sys.dm_db_index_operational_stats and sys.dm_db_index_usage_stats.
      Consider eliminating unused and duplicate indexes, but this should be done carefully. Some indexes may only be used during monthly/quarterly/annual operations, and may be important for those processes. You may also consider creating indexes to support those operations just before the operations are scheduled, to reduce the overhead of having otherwise unused indexes on a table.
      Review and evaluate expensive queries from the Query Store, or Extended Events capture, and work to manually craft indexes to better serve those queries.
      Create the index(s) in a non-production environment, and test query execution and performance and observe performance changes. It is important to note any hardware differences between your production and non-production environments, as the amount of memory and the number of CPUs could impact your execution plan.
      After testing carefully, implement the changes to your production system.

  Maintain Indexes
    As data is inserted, updated, and deleted from indexes the logical ordering in the index will no longer match the physical ordering inside of the pages, and between the pages, making up the indexes. Also, over time the data modifications can cause the data to become scattered or fragmented in the database. This fragmentation can degrade query performance when the database engine needs to read additional pages in order to locate needed data.

    The SQL Server and Azure SQL platforms offer DMVs that allow you to detect fragmentation in your objects using the following DMVs. The most commonly used DMVs for this purpose are: sys.dm_db_index_physical_stats, for b-tree indexes, and sys.dm_dm_colum_store_row_group_physical_stats, for columnstore indexes.

    There are two options for index maintenance: reorganization, and rebuilding. Reorganization defragments an index by physically reordering the leaf-level index pages to match the logical sorted order of the leaf nodes and compacts the index pages based on the index’s fill factor setting. Rebuilding an index drops and recreates the pages of the index.

    One other thing to note is that index rebuilds cause the statistics on the index to be updated, which can further help performance. Index reorganization does not update statistics.

  Columnstore maintenance
    Columnstore index fragmentation is not reported in same manner as b-tree index fragmentation. Examine the sys.dm_dm_colum_store_row_group_physical_stats for deleted rows—which will be caused by both update and delete operations. A good metric to measure fragmentation in a columnstore index is based on the deleted rows in the index. If 20% or more of the rows are deleted, you should consider reorganizing your index. In a test environment, verify whether a reorganization improves the performance of the workloads using the columnstore index.
